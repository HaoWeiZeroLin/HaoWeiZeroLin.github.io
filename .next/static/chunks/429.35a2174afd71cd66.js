"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[429],{92003:function(t){t.exports=function({mustBeMetaMask:t=!1,silent:e=!1,timeout:i=3e3}={}){!function(){if("boolean"!=typeof t)throw Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");if("boolean"!=typeof e)throw Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");if("number"!=typeof i)throw Error("@metamask/detect-provider: Expected option 'timeout' to be a number.")}();let n=!1;return new Promise(s=>{window.ethereum?r():(window.addEventListener("ethereum#initialized",r,{once:!0}),setTimeout(()=>{r()},i));function r(){if(n)return;n=!0,window.removeEventListener("ethereum#initialized",r);let{ethereum:i}=window;if(i&&(!t||i.isMetaMask))s(i);else{let n=t&&i?"Non-MetaMask window.ethereum detected.":"Unable to detect window.ethereum.";e||console.error("@metamask/detect-provider:",n),s(null)}}})}},35796:function(t,e,i){i.d(e,{d:function(){return s}});var n=i(85783);class s extends n.J5{async init(t){this.chainConfig||(this.chainConfig=(0,n.h2)(n.EN.EIP155,1))}async authenticateUser(){if(!this.provider||this.status!==n.MP.CONNECTED)throw n.RM.notConnectedError();let{chainNamespace:t,chainId:e}=this.chainConfig,i=await this.provider.request({method:"eth_accounts"});if(i&&i.length>0){let s=(0,n.Cb)(i[0],this.name);if(s&&!(0,n.$E)(s))return{idToken:s};let r={domain:window.location.origin,uri:window.location.href,address:i[0],chainId:parseInt(e,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},a=await (0,n.tV)(r,t),o=await this.provider.request({method:"personal_sign",params:[a,i[0]]}),h=await (0,n.rn)(t,o,a,this.name,this.sessionTime,this.clientId,this.web3AuthNetwork);return(0,n.Fr)(i[0],this.name,h),{idToken:h}}throw n.RM.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();let t=await this.provider.request({method:"eth_accounts"});t&&t.length>0&&(0,n.qz)(t[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(n.n2.DISCONNECTED)}}},94429:function(t,e,i){i.d(e,{MetamaskAdapter:function(){return h}});var n=i(81180),s=i(92003),r=i.n(s),a=i(85783),o=i(35796);class h extends o.d{constructor(){super(...arguments),(0,n.Z)(this,"adapterNamespace",a.yk.EIP155),(0,n.Z)(this,"currentChainNamespace",a.EN.EIP155),(0,n.Z)(this,"type",a.hN.EXTERNAL),(0,n.Z)(this,"name",a.rW.METAMASK),(0,n.Z)(this,"status",a.MP.NOT_READY),(0,n.Z)(this,"metamaskProvider",null)}get provider(){return this.status!==a.MP.NOT_READY&&this.metamaskProvider?this.metamaskProvider:null}set provider(t){throw Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this.metamaskProvider=await r()({mustBeMetaMask:!0}),!this.metamaskProvider)throw a.Ty.notInstalled("Metamask extension is not installed");this.status=a.MP.READY,this.emit(a.n2.READY,a.rW.METAMASK);try{a.cM.debug("initializing metamask adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(t){this.emit(a.n2.ERRORED,t)}}async connect(){if(super.checkConnectionRequirements(),!this.metamaskProvider)throw a.RM.notConnectedError("Not able to connect with metamask");let{ethereum:t}=window;if(t&&t.isMetaMask&&"isPhantom"in t){if(t.providers&&t.providers.length>0){let e=t.providers.find(t=>t.isMetaMask&&!t.overrideIsMetaMask);e&&t.setProvider(e)}}else if(t&&(t.providers||[]).length>0){let e=t.providers.find(t=>t.isMetaMask);e&&t.setSelectedProvider(e)}this.status=a.MP.CONNECTING,this.emit(a.n2.CONNECTING,{adapter:a.rW.METAMASK});try{await this.metamaskProvider.request({method:"eth_requestAccounts"});let{chainId:t}=this.metamaskProvider;if(t!==this.chainConfig.chainId&&(await this.addChain(this.chainConfig,!0),await this.switchChain(this.chainConfig,!0)),this.status=a.MP.CONNECTED,!this.provider)throw a.RM.notConnectedError("Failed to connect with provider");let e=()=>{var t;this.disconnect(),null===(t=this.provider)||void 0===t||t.removeListener("disconnect",e)};return this.provider.on("disconnect",e),this.emit(a.n2.CONNECTED,{adapter:a.rW.METAMASK,reconnected:this.rehydrated}),this.provider}catch(t){if(this.status=a.MP.READY,this.rehydrated=!1,this.emit(a.n2.ERRORED,t),t instanceof a.up)throw t;throw a.RM.connectionError("Failed to login with metamask wallet")}}async disconnect(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession(),null===(t=this.provider)||void 0===t||t.removeAllListeners(),e.cleanup?(this.status=a.MP.NOT_READY,this.metamaskProvider=null):this.status=a.MP.READY,await super.disconnect()}async getUserInfo(){if(this.status!==a.MP.CONNECTED)throw a.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(t){var e;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkAddChainRequirements(t,i),await (null===(e=this.metamaskProvider)||void 0===e?void 0:e.request({method:"wallet_addEthereumChain",params:[{chainId:t.chainId,chainName:t.displayName,rpcUrls:[t.rpcTarget],blockExplorerUrls:[t.blockExplorer],nativeCurrency:{name:t.tickerName,symbol:t.ticker,decimals:t.decimals||18}}]})),this.addChainConfig(t)}async switchChain(t){var e;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkSwitchChainRequirements(t,i),await (null===(e=this.metamaskProvider)||void 0===e?void 0:e.request({method:"wallet_switchEthereumChain",params:[{chainId:t.chainId}]})),this.setAdapterSettings({chainConfig:this.getChainConfig(t.chainId)})}}}}]);